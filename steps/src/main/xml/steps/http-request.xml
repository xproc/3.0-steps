<section xmlns="http://docbook.org/ns/docbook"
         xmlns:cs="http://www.w3.org/XML/XProc/2006/04/components#"
         xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax"
         xmlns:p="http://www.w3.org/ns/xproc"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="c.http-request">
<title>p:http-request</title>

<para>The <code>p:http-request</code> step provides for interaction
with resources over HTTP or related protocols.</para>

<p:declare-step type="p:http-request">
  <p:input port="source" content-types="any" sequence="true"/>
  <p:output port="result" primary="true" content-types="any" sequence="true" />
  <p:output port="report" content-types="application/json" />
  <p:option name="href" as="xs:anyURI" required="true" />
  <p:option name="method" as="xs:string?" select="'GET'" />
  <p:option name="serialization" as="map(xs:QName,item()*)?"/>
  <p:option name="headers" as="map(xs:string, xs:string)?" />
  <p:option name="auth" as="map(xs:string, item()+)?" />
  <p:option name="parameters" as="map(xs:QName, item()*)?" />
  <p:option name="assert" as="xs:string" select="'.?status-code lt 400'" />
</p:declare-step>
  
<para>In the most simple case, the HTTP request is controlled by the <option>href</option>
option and the <option>method</option> option which defaults to 
“<literal>GET</literal>”. The <option>method</option> option specifies the method 
  to be used against the IRI specified by the <option>href</option>, 
  e.g. GET or POST.</para>
  
<para>The request body is constructed using the document(s) appearing on the 
<port>source</port> port. The 
<option>serialization</option> option is used to
control the serialization for these documents in the request body. If a document 
has a “<literal>serialization</literal>” property,
the serialization is controlled by the merger of the two maps, where the entries in the
“<literal>serialization</literal>” property take precedence.</para> 
<para>If exactly one document appears on the <port>source</port> port, the request headers
  are constructed using entries in the document's properties and the headers 
  provided with the <option>headers</option> options (see below).
  If no document appears on the <port>source</port> port, the request body will be
empty and the headers will be constructed using the <option>headers</option> options.</para>
  
  <note xml:id="note-http-methods">
    <para>Implementors are encouraged
      to support as many protocols as practical. In particular, pipeline authors may
      attempt to use <tag>p:http-request</tag> to load documents with computed
      URIs using the <literal>file:</literal> scheme.</para></note>
  
<para>The results of performing an HTTP request will appear on the <port>result</port>
port and the <port>report</port> port. If the request was successful, the documents
contained in the message body (if any) will appear on the <port>result</port> port. The
distinction between XML documents, HTML documents, text documents etc. is made  using the
response header's “<literal>Content-Type</literal>” or the entry “<literal>content-type</literal>”
in the map provided as the <option>parameters</option> option (see below).
The response's status code and the response's header fields will be made available on
the <port>response</port> port as a <literal>map</literal>. The keys 
“<literal>status-code</literal>” (associated with an instance of <code>xs:integer</code>) 
and “<literal>headers</literal>” (associated with a <code>map(xs:string, xs:string)</code>)
will always be present, although the map may be empty. Header names are
converted to uppercase.</para>
  
<para>For the convenience of pipeline authors, <tag>p:http-request</tag> accepts documents
on the <port>source</port> port even when the semantics of sending a payload with the
specified request method (like “<literal>GET</literal>” or “<literal>HEAD</literal>”) is not defined. 
For those methods the documents on the <port>source</port> are ignored when constructing
  the request, unless the <option>parameters</option> option associates the key 
  “<literal>send-body-anyway</literal>” explicitly with <code>true()</code>.</para>
  
<para>The <tag>p:http-request</tag> step has the following options:</para>
  <variablelist>
    <varlistentry>
      <term><option>href</option></term>
      <listitem>
        <para>The <option>href</option> specifies the request's IRI. Relative values are resolved against the base URI of 
                 the element on which the option is 
          specified (<tag>p:with-option</tag>  or the step in case of a syntactic shortcut value).</para>
        <para>Fragment identifiers will be removed. Query parameters are
          passed through unchanged. <error code="C0128">It is a <glossterm>dynamic error</glossterm> if
          the URI’s scheme is unknown or not supported.</error></para>
        <note xml:id="http-uri-query" role="editorial">
          <title>Editorial Note</title>
          <para>What do we say about URI escaping?</para>
        </note>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><option>method</option></term>
      <listitem>
        <para>The <option>method</option> specifies the request's method. The value is implicitly
        turned into an uppercase string if necessary. <impl>It is <glossterm>implementation defined</glossterm>
          which HTTP methods are supported.</impl> An implementation <rfc2119>should</rfc2119> at least implement
          the methods <literal>GET</literal>, <literal>POST</literal>, <literal>PUT</literal>, 
          <literal>DELETE</literal>, and <literal>HEAD</literal> (for HTTP). <error code="C0122">It is a
          <glossterm>dynamic error</glossterm> if the given method is not supported.</error></para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><option>serialization</option></term>
      <listitem>
        <para>If present, the map provided for the <option>serialization</option> option is used to
        control the serialization of the documents on the <port>source</port> port. If one of this 
          documents has a “<literal>serialization</literal>” property,
          the serialization is controlled by the merger of the two maps where the entries in the
          “<literal>serialization</literal>” property takes precedence.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><option>headers</option></term>
      <listitem>
        <para>If present, the key/value pairs are used to construct the request headers. The request
        headers effectively to be send are constructed as follow:</para>
          <orderedlist>
            <listitem><para>If exactly one document appears on the <port>source</port> port, the document 
              property except “<literal>base-uri</literal>” and “<literal>serialization</literal>” will be 
              taken as request headers. Otherwise an empty map is used for the following construction steps.</para>
            </listitem>
            <listitem>
              <para>This header map is then merged with the entries of the <option>headers</option> option
                (if present), where the latter takes precedence. This means for instance that the document property 
                “<literal>content-type</literal>” is overwritten by an entry for “<literal>Content-Type</literal>” 
                (in the map provided for the <option>headers</option> option).</para>
            </listitem>
            <listitem>
              <para>Any entry for key “<literal>Authorization</literal>” is then overwritten or removed according
              to the values provided for the <option>auth</option> option (if present).</para>
            </listitem>
          </orderedlist>
          <para>As HTTP headers are case-insensitive but keys in maps are not, be careful when specifying
            the request's headers. <error code="C0127">It is a <glossterm>dynamic error</glossterm> if the 
              effective map from which the HTPP headers are constructed contains two keys which are case-blind
            equal (<code>fn:uppercase($key1) = fn:uppercase($key2)</code>).</error></para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><option>auth</option></term>
      <listitem>
        <para>The map provided for the <option>auth</option> is used to control the authentication process for
        the HTTP request. If no value or an empty map is provided, the value provided for
        HTTP header “<literal>Authorization</literal>” (if present) is used as authentication. The following keys and 
          the expected type of their associated values are predefined: “<literal>username</literal>” (<code>xs:string</code>),
          “<literal>password</literal>” (<code>xs:string</code>), “<literal>auth-method</literal>” (<code>xs:string</code>),
          "<literal>preemptive-auth</literal>” (<code>xs:boolean</code>), and “<literal>certificates</literal>”
          (<code>map(xs:string, item()+)+</code>). <impl>Other key value pairs in map “<literal>auth</literal>” are 
            <glossterm>implementation defined</glossterm>.</impl> <error code="C0123">It is a <glossterm>dynamic
              error</glossterm> if any key in the “<literal>auth</literal>” map  is associated with a value that is
            not an instance of the required type.</error></para>
        <para>For the purposes of avoiding an authentication challenge, if the “<literal>send-authorization</literal>”
          key is associated with <literal>true()</literal> and the authentication method specified by the value associated
          with the “<literal>auth-method</literal>” key supports generation of an “<literal>Authorization</literal>” header 
          without a challenge, then the header is generated and sent on the first request. If the 
          “<literal>send-authorization</literal>” key is absent, is not associated with an instance of
          <code>xs:boolean</code> or has the value <literal>false()</literal>, then the first request is sent 
          without an “<literal>Authorization</literal>” header.</para>
        <para>If the initial response to the request is an authentication challenge, the values provided for the
          “<literal>auth-method</literal>”, “<literal>username</literal>”, “<literal>password</literal>” keys and 
          any relevant data from the challenge are used to generate an “<literal>Authorization</literal>” header 
          and the request is sent again. If that authorization fails, the request is not retried.</para>
        <para>Appropriate values for the “<literal>auth-method</literal>” key are “<literal>Basic</literal>” 
          or “<literal>Digest</literal>” but other values are allowed. If the authentication method 
          is “<literal>Basic</literal>” or “<literal>Digest</literal>”, authentication is handled 
          as per <biblioref linkend="rfc2617"/>. <impl>The interpretation of values 
            associated with the “<literal>auth-method</literal>” key other 
            than “<literal>Basic</literal>” or “<literal>Digest</literal>” is
            <glossterm>implementation defined</glossterm>.</impl></para>
        <para><error code="C0003">It is a <glossterm>dynamic error</glossterm> if a “<literal>username</literal>”
          or a “<literal>password</literal>” key is present without specifying a value for the 
          “<literal>auth-method</literal>” key, if the requested <literal>auth-method</literal> isn't supported, 
          or the authentication challenge contains an authentication method that isn't
          supported.</error> All implementations <rfc2119>must</rfc2119> support “Basic”
          and “Digest” authentication per <biblioref linkend="rfc2617"/>.</para>
        <para>Additionally certificates may be provided for authenticating the client with the server.<impl>The
        support and interpretation of the values associated with key “<literal>certificates</literal>” are
        implementation defined.</impl></para>
        <note xml:id="c.http-certificate" role="editorial">
          <title>Editorial Note</title>
          <para>TBD: I think we need to say more about certificates.</para>
        </note>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>parameters</term>
      <listitem>
        <para>The <option>parameter</option> option can be used to provide values for fine tuning the
        construction of the request and/or the handling of the servers response. The following key-value pairs, the
        required value type and their semantics are predefined. <impl>It is <glossterm>implementation defined</glossterm>
        which other key-value pairs in the <option>parameters</option> option are supported.</impl> 
          <error code="C0124">It is a <glossterm>dynamic error</glossterm> if any key in the “parameters” map is 
            associated with a value that is not an instance of the required type.</error></para>
        <variablelist>
          <varlistentry>
            <term>override-content-type</term>
            <listitem>
              <para>The value associates with the “<literal>override-content-type</literal>” key controls interpretation of the 
                response's <literal>Content-Type</literal> header. The value must be an instance of <code>xs:string</code>.
                If the key-value pair is present, the response will be treated as if the response contained a
                “<literal>Content-Type</literal>” header given by its value. 
                The original Content-Type header will however be reflected unchanged as entry in the document on the 
                <port>report</port> port. <error code="C0030">It is a <glossterm>dynamic error</glossterm> if the 
                  value cannot be used (e.g. application/json to override application/xml).</error></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>http-version</term>
            <listitem>
              <para>The value associated with the “<literal>http-version</literal>” key must be an instance of
              <code>xs:string</code>. It indicated which HTTP version has to be used for the request.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>multipart</term>
            <listitem>
              <para>The key “<literal>multipart</literal>” must be associated with an instance of 
                <code>xs:boolean</code>. If the associated value is <code>false()</code> a <glossterm>dynamic 
                  error</glossterm> will be raised, if a multipart response is delivered by the server. This feature
                relieves pipeline authors from testing the number of documents delivered from 
                <tag>p:http-request</tag> if the receiving steps have a non-sequence input port. <error code="C0125">It
                is a <glossterm>dynamic error</glossterm> if key “<literal>multipart</literal>” is associated
                with <code>false()</code> and a multipart response is detected.</error></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>content-encoding</term>
            <listitem>
              <para>The value associated with the “<literal>content-encoding</literal>” key must be an instance
              of <code>xs:string</code>. If the key-value pair is present, the response will be treated as if the response
              contained a “<literal>Content-Encoding</literal>” header given by its value. The original Content-Encoding
              will however be reflected unchanged as entry in the document on the <port>report</port> port.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>transfer-encoding</term>
            <listitem>
              <note xml:id="http-uri-transfer-encoding" role="editorial">
                <title>Editorial Note</title>
                <para>TBD: How does this entry differ from the "transfer-encoding" header?</para>
              </note>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>permit-expired-ssl-certificate</term>
            <listitem>
              <para>The “<literal>permit-expired-ssl-certificate</literal>” key must be associated with
              a value which is an instance of <code>xs:boolean</code>. If it is associated with 
                <code>true()</code> it allows HTTPS requests to still work when the server
              provides an SSL certificate which has expired.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>permit-untrusted-ssl-certificate</term>
            <listitem>
              <para>The value associated with the “<literal>permit-untrusted-ssl-certificate</literal>” must
                be an instance of <code>xs:boolean</code>. If it is <code>true()</code> it allows HTTPS requests 
                to still work when the server provides an SSL certificate which is not trusted, 
                this may be because the CA (Certificate Authority) is unknown.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>follow-redirect</term>
            <listitem>
              <para>The “<literal>follow-redirect</literal>” must be associated with an instance of
              <code>xs:integer</code>. It allows to specify the step’s behaviour in case of a redirect
                response. <literal>0</literal> indicates that redirects are not to be followed, 
                <literal>-1</literal> indicates that redirects are to be followed indefinitely, a
                specific number indicates the maximum number of redirects to follow. <impl>The default
              behaviour in case of a redirect response is <glossterm>implementation defined</glossterm>.</impl></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>timeout</term>
            <listitem>
              <para>The value associated with the “<literal>timeout</literal>” key must be a non-negative
                instance of <code>xs:decimal</code>. It controls the time the XProc processor is
                waiting for the request to be answered. If a value is given for <code>timeout</code>
                it is taken as the number of seconds to wait for the response to be delivered.
                If no response is received after that time, the request is terminated and a status-code
                <literal>408</literal> is assumed.</para>
              </listitem>
            </varlistentry>
          <varlistentry>
            <term>fail-on-timeout</term>
            <listitem>
              <para>The value associated with the 
                “<literal>fail-on-timeout</literal>” key which must be an instance of <code>xs:boolean</code>. If
              the key is present and is associated with <code>true()</code>, a dynamic error is raised in case of
                a status code <literal>408</literal> (either as a consequence of setting a value for the 
                “<literal>timeout</literal>” key or as status code returned by a server).
                <error code="C0078">It is a <glossterm>dynamic error</glossterm>
                  if the value associated with the “<literal>fail-on-timeout</literal>” is associated with 
                  <code>true()</code> and a HTTP status code <literal>408</literal> is encountered.</error></para>
              <note>
                <title>Note</title>
                <para>Please note the difference between attribute <code>timeout</code>
                  on <code>p:http-request</code> and the key “<literal>fail-on-timeout</literal>” in the
                  <option>parameters</option> map:
                  If the step does not finish in the set time,
                  <code>D0053</code> is raised. If the request does not finish in time
                  and fail-on-timeout is true, <code>C0078</code> is raised. The actual
                  times after which a timeout is detected may also differ slightly.
                </para>
              </note>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>status-only</term>
            <listitem>
              <para>The “<literal>status-only</literal>” may be used to save resources on parsing the response 
                when the pipeline author is only interested in the response code. The key must be associated with
              an instance of <code>xs:boolean</code>. If it is associated with <literal>true()</literal>, an empty 
              sequence is return on the <port>result</port> port and the map on the <port>report</port> 
                will contain the status code and an empty map for “<literal>headers</literal>”.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>suppress-cookies</term>
            <listitem>
              <para>The key “<literal>suppress-cookies</literal>” must be associated with an instance of 
              <code>xs:boolean</code>. If the value is <code>true()</code>, no cookies must be send
              with the HTTP request.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>send-body-anyway</term>
            <listitem>
              <para>The key “<literal>send-body-anyway</literal>” must be associated with an instance of 
                <code>xs:boolean</code>. If the value is <code>true()</code>, a request body is constructed
              from the documents appearing on the <port>source</port> port although the semantics of
              sending a body is not specified for the used HTTP method.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>assert</term>
      <listitem>
        <para>The <option>assert</option> option can be used by pipeline authors to raise a dynamic error
        if the response does not fulfill the expectations of the receiving step sequence. The option's
        value (if present) is interpreted as an XPath expression which will be executed taking the map
        to appear on the <port>report</port> port as context item. Function <code>fn:boolean</code> is
        then evaluated on the expression's result. If the result is <code>false()</code>, a 
          <glossterm>dynamic error</glossterm> is raised. <error code="C0126">It is a 
            <glossterm>dynamic error</glossterm> if the XPath expression in
            <option>assert</option> evaluates to <code>false</code>.</error> Implementations 
          <rfc2119>should</rfc2119> provide an XML representation of the map used as context item 
          with the error document to enable pipelines to access the error' cause.</para>
      </listitem>
    </varlistentry>
  </variablelist>

  <section xml:id="c.http-multipart-request">
    <title>Construction of a multi-part request</title>
    <note xml:id="c.http-multipart.multi-part-request" role="editorial">
      <title>Editorial Note</title>
      <para>TBD.</para>
    </note>
  </section>

  <section xml:id="c.http-multipart-response">
    <title>Managing a multi-part response</title>
    <note xml:id="c.http-multipart.multi-part-request" role="editorial">
      <title>Editorial Note</title>
      <para>TBD.</para>
    </note>
  </section>
  
<simplesect>
<title>Document properties</title>
<para feature="http-request-preserves-none">No document properties are preserved.</para>
</simplesect>
</section>
